---
title: "KIRC Validation "
output: html_notebook
---


```{r}
packages_cran = c("tidyverse")
  
#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed from CRAN and loaded
package.check <- lapply(packages_cran, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
    library(x, character.only = TRUE)
  }
})

library(stats) # MDS
library("glmpca")
library(ggplot2)
library(ggfortify)
library(survC1)
library(survAUC)
library(glmnet)
library(gbm)
library(mboost)
library(finalfit)

rm(packages_cran, package.check)
```


# Load Processed data

```{r}
load("../data/1.data.processed.rda")

library(finalfit)
# Crosstable 
explanatory = c("obs.time", "status", "age", "gender", "neoplasm", "metastasis", "ajcc.stage")
dependent = 'dataset'
data %>%
  mutate(status = case_when(status==1 ~ "Deceased",
                            status==0 ~ "Alive")) %>%
  mutate(gender = case_when(gender==1 ~ "Male",
                            gender==0 ~ "Female")) %>%
  summary_factorlist(dependent, explanatory, 
  p=TRUE, add_dependent_label=TRUE) -> t1
knitr::kable(t1, align=c("l", "l", "r", "r", "r"))


```

# Train 66% of TCGA, test holdout 33% of TCGA



```{r}
library(survC1)
library(survAUC)
  
for(sign in gsign_kidney$id[c(1:23,25:28)]) {
  print(sign)
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data))
  
  #set.seed(1) ## for reproducibility
    
  fold1 <- sample(1:nrow(data_tcga),size=floor(nrow(data_tcga)/3))
  fold2 <- sample(setdiff(1:nrow(data_tcga), fold1), size=floor(nrow(data_tcga)/3))
  fold3 <- setdiff(1:nrow(data_tcga), union(fold1,fold2))
  
  x <- (data[, col_sign] +1)
  y <- Surv(data$obs.time, data$status)
  y_tr <- y[-fold1]
  x_tr <- x[-fold1,]
  y_te <- y[fold1]
  x_te <- x[fold1,]
  
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")
  
  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
  
  levs <- cut_number(preds,3)
  
  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  print(paste0("p-val: ", p.val))
  
  
  mydata <- data.frame(as.matrix(y_te),preds)
  out <- Est.Cval(mydata, 3000, nofit=TRUE)
  cind <- out$Dhat
  print(paste0("C-index: ", cind))
  
  times <- seq(10, 3000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  print(paste0("AUC_Uno: ", AUC_Uno$iauc)) 
  
  print("---")
  
  if(p.val< 0.05){
    try({
    pdf(file=paste0("../plots/surv/TCGA-", sign,".pdf"), width = 14, height = 10)
    
       print(autoplot(fit,xlab="Survival Time (days)",ylab="Survival",
              main=paste0(sign , " / p-value: ", round(p.val,6), " / C-index: ", round(cind,3), " / AUC: ", round(AUC_Uno$iauc,3))))
    
    dev.off()
    }, silent = T)
  }
}  
  
```

# Train 66% of TCGA, test holdout 33% of TCGA - 100 repeats

```{r}
library(survC1)
library(survAUC)

bmk <- setNames(data.frame(matrix(nrow=0, ncol=6)), c("sign", "iteration", "fold", "p.val", "cind", "auc_uno"))

for(sign in gsign_kidney$id[c(1:23,25:28)]) {
  #print(sign)
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data_tcga))
  
  for(i in c(1:10)){
  #set.seed(1) ## for reproducibility
  fold1 <- sample(1:nrow(data_tcga),size=floor(nrow(data_tcga)/3))
  fold2 <- sample(setdiff(1:nrow(data_tcga), fold1), size=floor(nrow(data_tcga)/3))
  fold3 <- setdiff(1:nrow(data_tcga), union(fold1,fold2))
  
  folds <- list(fold1, fold2, fold3)
  f <- 1
  for(fd in folds){
    x <- (data_tcga[, col_sign] +1)
    y <- Surv(data_tcga$obs.time, data_tcga$status)
    y_tr <- y[-fd]
    x_tr <- x[-fd,]
    y_te <- y[fd]
    x_te <- x[fd,]
    
    cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")
    
    preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
    
    levs <- cut_number(preds,3)
    
    fit <- survfit(y_te~levs)
    out <- survdiff(y_te~levs)
    p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
    #print(paste0("p-val: ", p.val))
    
    
    mydata <- data.frame(as.matrix(y_te),preds)
    out <- Est.Cval(mydata, 3000, nofit=TRUE)
    cind <- out$Dhat
    #print(paste0("C-index: ", cind))
    
    times <- seq(10, 3000, 10)                  
    AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
    auc_uno <- AUC_Uno$iauc
    #print(paste0("AUC_Uno: ", auc_uno)) 
    df <- setNames(data.frame(sign, i, f, p.val, cind, auc_uno), c("sign", "iteration", "fold", "p.val", "cind", "auc_uno"))
    
    bmk <- rbind(bmk,  df)
    f <- f+1
  }
  }
} 


bmk %>% group_by(sign) %>% 
  summarise(auc=mean(auc_uno)) %>% 
  arrange(desc( auc)) %>% 
  knitr::kable(.)

bmk %>% group_by(sign) %>%
  summarise(p=mean(p.val)) %>% 
  arrange( p) %>% 
  knitr::kable(.)


```

# Train TCGA Test ICGC

```{r}
library(survC1)
library(survAUC)

for(sign in gsign_kidney$id[c(1:23,25:28)]) {
  print(sign)
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data))
  
  ix <- c(1:nrow(data))[data$dataset == "TCGA"]
  
  x <- (data[, col_sign] +1)
  y <- Surv(data$obs.time, data$status)
  y_tr <- y[ix]
  x_tr <- x[ix,]
  y_te <- y[-ix]
  x_te <- x[-ix,]
  
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")

  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")

  levs <- cut_number(preds,3)
  
  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  print(paste0("p-val: ", p.val))
  
  
  mydata <- data.frame(as.matrix(y_te),preds)
  out <- Est.Cval(mydata, 3000, nofit=TRUE)
  cind <- out$Dhat
  print(paste0("C-index: ", cind))

  times <- seq(10, 3000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  print(paste0("AUC_Uno: ", AUC_Uno$iauc)) 

  print("---")
  
  if(p.val< 0.05){
    try({
    pdf(file=paste0("../plots/surv/ICGC-", sign,".pdf"), width = 14, height = 10)
    
       print(autoplot(fit,xlab="Survival Time (days)",ylab="Survival",
              main=paste0(sign , " / p-value: ", round(p.val,6), " / C-index: ", round(cind,3))))
    
    dev.off()
    }, silent = T)
  }
}
```



# Train TCGA Test ICGC - 100 repeats

```{r}

library(survC1)
library(survAUC)

bmk_icgc <- setNames(data.frame(matrix(nrow=0, ncol=6)), c("sign", "iteration", "p.val", "cind", "auc_uno"))

for(sign in gsign_kidney$id[c(1:23,25:28)]) {
  print(sign)
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data_tcga))
  
  for(i in c(1:10)){
  #set.seed(1) ## for reproducibility
  ix <- c(1:nrow(data))[data$dataset == "TCGA"]
  
  x <- (data[, col_sign] +1)
  y <- Surv(data$obs.time, data$status)
  y_tr <- y[ix]
  x_tr <- x[ix,]
  y_te <- y[-ix]
  x_te <- x[-ix,]
  
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr, nfolds=5, gamma = 0, relax = T, family="cox", type.measure="C")
  
  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
  
  levs <- cut_number(preds,3)
  
  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  #print(paste0("p-val: ", p.val))
  
  
  mydata <- data.frame(as.matrix(y_te),preds)
  out <- Est.Cval(mydata, 3000, nofit=TRUE)
  cind <- out$Dhat
  #print(paste0("C-index: ", cind))
  
  times <- seq(10, 3000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc
  #print(paste0("AUC_Uno: ", auc_uno)) 
  df <- setNames(data.frame(sign, i, p.val, cind, auc_uno), c("sign", "iteration", "p.val", "cind", "auc_uno"))
  
  bmk_icgc <- rbind(bmk_icgc,  df)
  }
} 


bmk_icgc %>% group_by(sign) %>% 
  summarise(auc=mean(auc_uno)) %>% 
  arrange(desc( auc)) %>% 
  knitr::kable(.)

bmk_icgc %>% group_by(sign) %>%
  summarise(p=mean(p.val)) %>% 
  arrange( p) %>% 
  knitr::kable(.)


```

# PCA - TCGA

```{r}
set.seed(1)
xi <- sample(1:nrow(data_tcga),size=floor(nrow(data_tcga)/2))
x <- (data_tcga[, col_sign] +1)
y <- Surv(data_tcga$obs.time, data_tcga$status)
y_tr <- y[-xi]
x_tr <- x[-xi,]
y_te <- y[xi]
x_te <- x[xi,]

cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")

preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")

levs <- cut_number(preds,3)

fit <- survfit(y_te~levs)
out <- survdiff(y_te~levs)
p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
#print(paste0("p-val: ", p.val))


mydata <- data.frame(as.matrix(y_te),preds)
out <- Est.Cval(mydata, 3000, nofit=TRUE)
cind <- out$Dhat
#print(paste0("C-index: ", cind))

times <- seq(10, 3000, 10)                  
AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
auc_uno <- AUC_Uno$iauc
```


```{r}
fit <- survfit(y_te~levs)
out <- survdiff(y_te~levs)
out
```


```{r}
data_tcga$risk <- "NA"
levs <- cut_number(preds,3)
levs <- as.character(as.numeric(levs))
data_tcga$risk[xi] <- as.character(fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low") )
data_tcga$risk  <-  factor(data_tcga$risk, levels=c("High", "Moderate", "Low"))

table(data_tcga$risk[xi],  ifelse(data_tcga$status[xi]==1, "Deceased", "Alive") ) %>% knitr::kable(., row.names=T)

```


```{r}
p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
p.val #  0.03844712
```



```{r}

library(ggplot2)
library(ggfortify)
autoplot(fit,xlab="Survival Time (days)",ylab="Survival",
         main=paste0("p-value: ",round(p.val,6)))
```


# UMAP 

```{r}
plot.umap <- function(x, labels, sign, pval, auc_uno,
         main=paste0("A UMAP visualization of the TCGA dataset ", sign, " / ", signif(pval, digits = 3), " / ", round(auc_uno, digits = 2)),
         colors=c("#ff7f00", "#e377c2", "#17becf"),
         pad=0.1, cex=0.6, pch=19, add=FALSE, legend.suffix="",
         cex.main=1, cex.legend=0.85) {

  layout = x
  if (is(x, "umap")) {
    layout = x$layout
  }

  xylim = range(layout)
  xylim = xylim + ((xylim[2]-xylim[1])*pad)*c(-0.5, 0.5)
  if (!add) {
    par(mar=c(0.2,0.7,1.2,0.7), ps=10)
    plot(xylim, xylim, type="n", axes=F, frame=F)
    rect(xylim[1], xylim[1], xylim[2], xylim[2], border="#aaaaaa", lwd=0.25)
  }
  points(layout[,1], layout[,2], col=colors[as.integer(labels)],
         cex=cex, pch=pch)
  mtext(side=3, main, cex=cex.main)

  labels.u = unique(labels)
  legend.pos = "topleft"
  legend.text = as.character(labels.u)
  if (add) {
    legend.pos = "bottomleft"
    legend.text = paste(as.character(labels.u), legend.suffix)
  }

  legend(legend.pos, legend=legend.text, inset=0.03,
         col=colors[as.integer(labels.u)],
         bty="n", pch=pch, cex=cex.legend)
}
```


```{r}
if(!require(umap)){install.packages("umap")}

#ix <- c(1:nrow(data))[data$dataset == "TCGA"]

for(sign in gsign_kidney$id) {
  print(sign)
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data_tcga))  
  set.seed(1)

    xi <- sample(1:nrow(data_tcga),size=floor(nrow(data_tcga)/2))
  x <- (data_tcga[, col_sign] +1)
  y <- Surv(data_tcga$obs.time, data_tcga$status)
  y_tr <- y[-xi]
  x_tr <- x[-xi,]
  y_te <- y[xi]
  x_te <- x[xi,]

  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")

  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")

  levs <- cut_number(preds,3)
  levs <- as.character(as.numeric(levs))
  data_tcga$risk[xi] <- as.character(fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low") )
  data_tcga$risk  <-  factor(data_tcga$risk, levels=c("High", "Moderate", "Low"))

  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)

  times <- seq(10, 3000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc

  icgc.umap = umap(data_tcga[xi, col_sign])
  plot.umap(icgc.umap, data_tcga$risk , sign, p.val, auc_uno)
}

```

```{r}
if(!require("FactoMineR")){install.packages("FactoMineR")}
if(!require('factoextra')){install.packages('factoextra')} # Extract and Visualize the Results of Multivariate Data Analyses. PCA. CA. MCA.
if(!require('corrplot')){install.packages('corrplot')} # A graphical display of a correlation matrix or general matrix

set.seed(1)

exp <- (data_tcga[ xi , col_mRMR]+1)
tcga.pca <- PCA(scale(exp), graph = FALSE, scale.unit = TRUE)

fviz_screeplot(tcga.pca, addlabels = TRUE)

var <- get_pca_var(tcga.pca)

#corrplot(head(tcga.pca$var$cos2, 10), is.corr=FALSE, method="pie")

fviz_cos2(tcga.pca, choice = "var", axes = 1:2, top = 20)#

fviz_pca_var(tcga.pca, col.var = "cos2" , select.var=list(cos2=8) , repel= T )#

fviz_pca_ind(tcga.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = data_tcga$risk[xi], # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)

tcga.km <- kmeans(tcga.pca$ind$coord, centers = 3, nstart = 20)
grp <- as.factor(tcga.km$cluster)


fviz_pca_ind(tcga.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = grp, # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)

```


# PCA - TCGA

```{r,  fig.width=10, fig.height=6}

set.seed(1)

exp <- (data_tcga[ xi , col_mRMR]+1)
PCA_raw <- prcomp((exp), scale. = FALSE)

percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                    status = ifelse(data_tcga$status[xi]==1, "Deceased", "Alive"),
                    risk = data_tcga$risk[xi],
                    metastasis =  data_tcga$metastasis[xi])

ggplot(dataGG, aes(x=PC1, y=PC2, shape = status, color = risk)) +
  geom_point() +
  geom_rug() +
  ggtitle("PCA on expression data of mRMR signature") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  #coord_fixed(ratio = 1) +
  scale_shape_manual(values = c(15,4)) + 
  scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) +
  ggsave("../plots/pca_mRMR_TCGA.pdf", width = 14, height = 9, units = c("in"))


fviz_pca_ind(PCA_raw,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = data_tcga$risk[xi], # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)
```


# PCA plot using Generalized PCA - TCGA
https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#pca-plot-using-generalized-pca

```{r}

library("glmpca")
set.seed(12)
xi <- sample(1:nrow(data_tcga),size=floor(nrow(data_tcga)/2))
x <- (data_tcga[, col_mRMR] +1)
y <- Surv(data_tcga$obs.time, data_tcga$status)
y_tr <- y[-xi]
x_tr <- x[-xi,]
y_te <- y[xi]
x_te <- x[xi,]

set.seed(12)
cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")
preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
levs <- cut_number(preds,3)
levs <- as.character(as.numeric(levs))
data_tcga$risk[xi] <- as.character(fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low") )
data_tcga$risk  <-  factor(data_tcga$risk, levels=c("High", "Moderate", "Low"))
  

df <- as.data.frame(t(data_tcga[xi, col_mRMR]))
df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
df <- (df+1)

#  Negative binomial with global overdispersion ----
set.seed(12)
gpca <- glmpca(df, L=2, fam="poi")
gpca.dat <- gpca$factors

gpca.dat$risk <- data_tcga$risk[xi]
gpca.dat$status <- ifelse(data_tcga$status[xi]==1, "Deceased", "Alive")

ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
  geom_point() +
  geom_rug() +
  ggtitle("Generalized PCA plot of ICGC data expression with mRMR genes") +
  xlab("PC1") +
  ylab("PC2") +
  #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
  #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  #coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(15,4)) + 
  scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) +
  ggsave("../plots/gpca_tcga_mRMR0.pdf", width = 11, height = 7, units = c("in"))

```

# PCA ICGC

```{r}
if(!require("FactoMineR")){install.packages("FactoMineR")}
if(!require('factoextra')){install.packages('factoextra')} # Extract and Visualize the Results of Multivariate Data Analyses. PCA. CA. MCA.
if(!require('corrplot')){install.packages('corrplot')} # A graphical display of a correlation matrix or general matrix

set.seed(1)

exp <- (data_icgc[ , col_mRMR]+1)
icgc.pca <- PCA(scale(exp), graph = FALSE, scale.unit = TRUE)

fviz_screeplot(icgc.pca, addlabels = TRUE)

var <- get_pca_var(icgc.pca)

#corrplot(head(icgc.pca$var$cos2, 10), is.corr=FALSE, method="pie")

fviz_cos2(icgc.pca, choice = "var", axes = 1:2, top = 20)#

fviz_pca_var(icgc.pca, col.var = "cos2" , select.var=list(cos2=8) , repel= T )#

fviz_pca_ind(icgc.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = data_icgc$risk, # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)

icgc.km <- kmeans(icgc.pca$ind$coord, centers = 3, nstart = 20)
grp <- as.factor(icgc.km$cluster)


fviz_pca_ind(icgc.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = grp, # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)

```


# PCA

```{r,  fig.width=10, fig.height=6}

set.seed(1)

exp <- (data_icgc[ , col_mRMR]+1)
PCA_raw <- prcomp((exp), scale. = FALSE)

percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                    status = ifelse(data_icgc$status==1, "Deceased", "Alive"),
                    risk = data_icgc$risk,
                    metastasis =  data_icgc$metastasis)

ggplot(dataGG, aes(x=PC1, y=PC2, shape = status, color = risk)) +
  geom_point() +
  geom_rug() +
  ggtitle("PCA on expression data of mRMR signature") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  #coord_fixed(ratio = 1) +
  scale_shape_manual(values = c(15,4)) + 
  scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) +
  ggsave("../plots/pca_mRMR.pdf", width = 14, height = 9, units = c("in"))


fviz_pca_ind(PCA_raw,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = data_icgc$risk, # color by groups
             palette = c("red3", "orange1", "green4"),
             addEllipses = T, # Concentration ellipses
             legend.title = "Risk"
)
```


# PCA plot using Generalized PCA
https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#pca-plot-using-generalized-pca

```{r}
library("glmpca")
set.seed(1)

ix <- c(1:nrow(data))[data$dataset == "TCGA"]
x <- (data[, col_mRMR] +1)
y <- Surv(data$obs.time, data$status)
y_tr <- y[ix]
x_tr <- x[ix,]
y_te <- y[-ix]
x_te <- x[-ix,]

# set.seed(1)
# cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")
# preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
# levs <- cut_number(preds,3)
# levs <- as.character(as.numeric(levs))
# data_icgc$risk <- as.character(fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low") )
# data_icgc$risk  <-  factor(data_icgc$risk, levels=c("High", "Moderate", "Low"))
  
set.seed(1)
cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr,family="cox")
preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
levs <- cut_number(preds,2)
levs <- as.character(as.numeric(levs))
data_icgc$risk <- as.character(fct_relevel(fct_recode(levs, Low = "1",  High = "2"), "High", "Low") )
data_icgc$risk  <-  factor(data_icgc$risk, levels=c("High", "Low"))


df <- as.data.frame(t(data_icgc[, col_mRMR]))
df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
df <- (df+1)

#  Negative binomial with global overdispersion ----
set.seed(1)
gpca <- glmpca(df, L=2, fam="nb2")
gpca.dat <- gpca$factors

gpca.dat$risk <- data_icgc$risk
gpca.dat$status <- ifelse(data_icgc$status==1, "Deceased", "Alive")

ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
  geom_point() +
  geom_rug() +
  ggtitle("Generalized PCA plot of ICGC data expression with mRMR genes") +
  xlab("PC1") +
  ylab("PC2") +
  #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
  #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  #coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(15,4)) +  
  scale_color_manual(values = c("#AF58BA", "#00CD6C")) + theme(aspect.ratio = 1) + 
  #scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) + c("#AF58BA", "#00CD6C")
  ggsave("../plots/gpca_icgc_mRMR_2_cluster.pdf", width = 11, height = 7, units = c("in"))

```

# Cut in two groups

```{r}

for(sign in gsign_kidney$id) {
  
  if(sign != "fs.genetic"){
  
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data))  
  set.seed(12)

  data_icgc <- data[data$dataset =="ICGC", ]
  
  ix <- c(1:nrow(data))[data$dataset == "TCGA"]
  x <- (data[, col_sign] +1)
  y <- Surv(data$obs.time, data$status)
  x_tr <- x[ix,]
  y_tr <- y[ix]
  x_te <- x[-ix,]
  y_te <- y[-ix]
  
  set.seed(12)
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr, nfolds=5, gamma = 0, relax = T, family="cox", type.measure="C")
  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
  levs <- cut_number(preds, 2)
  levs <- as.character(as.numeric(levs))
  data_icgc$risk <- as.character(fct_relevel(fct_recode(levs, Low = "1", High = "2"), "High", "Low") )
  
  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  
  times <- seq(10, 3000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc
    
  if(p.val< 0.05){
  try({
  pdf(file=paste0("../plots/icgc_2_cut/surv_icgc_", sign,".pdf"), width = 14, height = 10)
  surv <- data_icgc %>% 
      surv_plot("Surv(obs.time, status)", "risk" , 
                title = paste0("Signature ", sign ," / p-val: ", signif(p.val, 3), " / auc_uno: ", round(auc_uno, digits = 2)),
                risk.table.title = "Nº at risk (nº of deceased)",
                pval = TRUE, palette="npg", risk.table ="nrisk_cumevents")
    
    print(surv, newpage = FALSE)
  dev.off()
  }, silent = T)
  
  
  df <- as.data.frame(t(data_icgc[, col_sign]))
  df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
  df <- (df+1)
  
  #  Negative binomial with global overdispersion ----
  set.seed(1)
  gpca <- glmpca(df, L=2, fam="nb")
  gpca.dat <- gpca$factors
  
  gpca.dat$risk <- data_icgc$risk
  gpca.dat$status <- ifelse(data_icgc$status==1, "Deceased", "Alive")
  
  ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
    geom_point() +
    geom_rug() +
    ggtitle(paste0("Generalized PCA of ICGC data expression with ",  sign, " / p-val: ", signif(p.val, digits = 3), " / auc: ", round(auc_uno, digits = 2))) +
    xlab("PC1") +
    ylab("PC2") +
    #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
    #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
    theme(plot.title = element_text(hjust = 0.5))+
    #coord_fixed(ratio = sd_ratio) +
    scale_shape_manual(values = c(15,4)) + 
    scale_color_manual(values = c("#AF58BA", "#00CD6C")) + theme(aspect.ratio = 1) + 
    #scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) + c("#AF58BA", "#00CD6C")
    ggsave(paste0("../plots/icgc_2_cut/gpca_icgc_", sign , ".pdf"), width = 11, height = 7, units = c("in"))
  }
  }
}
```

```{r}

for(sign in gsign_kidney$id) {
    
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data_tcga))  
  set.seed(1)
  ix <- c(1:nrow(data))[data$dataset == "TCGA"]
  x <- (data[, col_sign] +1)
  y <- Surv(data$obs.time, data$status)
  x_tr <- x[ix,]
  y_tr <- y[ix]
  x_te <- x[-ix,]
  y_te <- y[-ix]
  
  set.seed(12) 
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr, nfolds=5, gamma = 0, relax = T, family="cox", type.measure="C")
    preds <- predict(cvfit_tr,data.matrix(x_te), s="lambda.min")
  levs <- cut_number(preds,3)
  levs <- as.character(as.numeric(levs))
  data_icgc$risk <- fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low")
  
  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  
  times <- seq(10, 4000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc
    
  if(p.val< 0.05){
  try({
    pdf(file=paste0("../plots/icgc_3_cut/surv_icgc_", sign,".pdf"), width = 14, height = 10)
    surv <- data_icgc %>% 
      surv_plot("Surv(obs.time, status)", "risk" , 
                title = paste0("Signature ", sign ," / p-val: ", signif(p.val, 3), " / auc_uno: ", round(auc_uno, digits = 2)),
                risk.table.title = "Nº at risk (nº of deceased)",
                pval = TRUE, palette="npg", risk.table ="nrisk_cumevents")
    
    print(surv, newpage = FALSE)
    dev.off()
  }, silent = T)

  
  df <- as.data.frame(t(data_icgc[, col_sign]))
  df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
  df <- (df+1)
  
  #  Negative binomial with global overdispersion ----
  set.seed(1)
  gpca <- glmpca(df, L=2, fam="nb")
  gpca.dat <- gpca$factors
  
  gpca.dat$risk <- data_icgc$risk
  gpca.dat$status <- ifelse(data_icgc$status==1, "Deceased", "Alive")
  
  ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
    geom_point() +
    geom_rug() +
    ggtitle(paste0("Generalized PCA of ICGC data expression with ",  sign, " / p-val: ", signif(p.val, digits = 3), " / auc: ", round(auc_uno, digits = 2))) +
    xlab("PC1") +
    ylab("PC2") +
    #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
    #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
    theme(plot.title = element_text(hjust = 0.5))+
    #coord_fixed(ratio = sd_ratio) +
    scale_shape_manual(values = c(15,4)) + 
    #scale_color_manual(values = c("#AF58BA", "#00CD6C")) + theme(aspect.ratio = 1) + 
    scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) + 
    ggsave(paste0("../plots/icgc_3_cut/gpca_icgc_", sign , ".pdf"), width = 11, height = 7, units = c("in"))
  }
}

```

# FILTERING SAMPLES

```{r}

for(sign in gsign_kidney$id) {
  
  if(sign != "fs.genetic"){
  
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data))  
  set.seed(12)

  data.filt <- data[data$obs.time > 20 & data$obs.time < 2555, ]
  data_icgc.filt <- data.filt[data.filt$dataset =="ICGC", ]
  
  ix <- c(1:nrow(data.filt))[data.filt$dataset == "TCGA"]
  x <- (data.filt[, col_sign] +1)
  y <- Surv(data.filt$obs.time, data.filt$status)
  x_tr <- x[ix,]
  y_tr <- y[ix]
  x_te <- x[-ix,]
  y_te <- y[-ix]
  
  set.seed(12)
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr, nfolds=5, gamma = 0, relax = T, family="cox", type.measure="C")
  preds <- predict(cvfit_tr, data.matrix(x_te), s="lambda.min")
  levs <- cut_number(preds, 2)
  levs <- as.character(as.numeric(levs))
  data_icgc.filt$risk <- as.character(fct_relevel(fct_recode(levs, Low = "1", High = "2"), "High", "Low") )
  data_icgc.filt$risk  <-  factor(data_icgc.filt$risk, levels=c("High", "Low"))

  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  
  times <- seq(10, 2000, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc
    
  if(p.val< 0.05){
  try({
    pdf(file=paste0("../plots/icgc_2_cut_filt/surv_icgc_", sign,".pdf"), width = 14, height = 10)
    surv <- data_icgc.filt %>% 
      surv_plot("Surv(obs.time, status)", "risk" , 
                title = paste0("Signature ", sign ," / p-val: ", signif(p.val, 3), " / auc_uno: ", round(auc_uno, digits = 2)),
                risk.table.title = "Nº at risk (nº of deceased)",
                pval = TRUE, palette="npg", risk.table ="nrisk_cumevents")
    
    print(surv, newpage = FALSE)
    dev.off()
  }, silent = T)
  
  df <- as.data.frame(t(data_icgc.filt[, col_sign]))
  df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
  df <- (df+1)
  
  #  Negative binomial with global overdispersion ----
  set.seed(1)
  gpca <- glmpca(df, L=2, fam="nb")
  gpca.dat <- gpca$factors
  
  gpca.dat$risk <- data_icgc.filt$risk
  gpca.dat$status <- ifelse(data_icgc.filt$status==1, "Deceased", "Alive")
  
  ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
    geom_point() +
    geom_rug() +
    ggtitle(paste0("Generalized PCA of ICGC data expression with ",  sign, " / p-val: ", signif(p.val, digits = 3), " / auc: ", round(auc_uno, digits = 2))) +
    xlab("PC1") +
    ylab("PC2") +
    #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
    #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
    theme(plot.title = element_text(hjust = 0.5))+
    #coord_fixed(ratio = sd_ratio) +
    scale_shape_manual(values = c(15,4)) + 
    scale_color_manual(values = c("#AF58BA", "#00CD6C")) + theme(aspect.ratio = 1) + 
    #scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) + c("#AF58BA", "#00CD6C")
    ggsave(paste0("../plots/icgc_2_cut_filt/gpca_icgc_", sign , ".pdf"), width = 11, height = 7, units = c("in"))
  }
}
}
```

```{r}

for(sign in gsign_kidney$id) {
  
  if(sign != "fs.genetic"){
    
  col_sign <- intersect(gsign_kidney[sign, "signature"][[1]], names(data_tcga))  
  set.seed(1)
  data.filt <- data[data$obs.time > 20 & data$obs.time < 2555, ]
  data_icgc.filt <- data.filt[data.filt$dataset =="ICGC", ]

  ix <- c(1:nrow(data.filt))[data.filt$dataset == "TCGA"]
  x <- (data.filt[, col_sign] +1)
  y <- Surv(data.filt$obs.time, data.filt$status)
  x_tr <- x[ix,]
  y_tr <- y[ix]
  x_te <- x[-ix,]
  y_te <- y[-ix]
  
  set.seed(12)
  cvfit_tr <- cv.glmnet(data.matrix(x_tr),y_tr, nfolds=5, gamma = 0, relax = T, family="cox", type.measure="C")
  preds <- predict(cvfit_tr,data.matrix(x_te),s="lambda.min")
  levs <- cut_number(preds,3)
  levs <- as.character(as.numeric(levs))
  data_icgc.filt$risk <- fct_relevel(fct_recode(levs, Low = "1", Moderate = "2", High = "3"), "High", "Moderate", "Low")

  fit <- survfit(y_te~levs)
  out <- survdiff(y_te~levs)
  p.val <- 1 - pchisq(out$chisq, length(out$n) - 1)
  
  times <- seq(10, 2500, 10)                  
  AUC_Uno <- AUC.uno(y_tr, y_te, preds, times)
  auc_uno <- AUC_Uno$iauc
    
  if(p.val< 0.05){
  try({
    pdf(file=paste0("../plots/icgc_3_cut_filt/surv_icgc_", sign,".pdf"), width = 11, height = 7)
    surv <- data_icgc.filt %>% 
      surv_plot("Surv(obs.time, status)", "risk" , 
                title = paste0("Signature ", sign ," / p-val: ", signif(p.val, 3), " / auc_uno: ", round(auc_uno, digits = 2)),
                risk.table.title = "Nº at risk (nº of deceased)",
                pval = TRUE, palette="npg", risk.table ="nrisk_cumevents")
    
    print(surv, newpage = FALSE)
    dev.off()
  }, silent = T)
  
  df <- as.data.frame(t(data_icgc.filt[, col_sign]))
  df <- df[apply(df[,-1], 1, function(x) !all(x==0)),]
  df <- (df+1)
  
  #  Negative binomial with global overdispersion ----
  set.seed(1)
  gpca <- glmpca(df, L=2, fam="nb2")
  gpca.dat <- gpca$factors
  
  gpca.dat$risk <- data_icgc.filt$risk
  gpca.dat$status <- ifelse(data_icgc.filt$status==1, "Deceased", "Alive")
  
  ggplot(gpca.dat, aes(x=dim1, y=dim2, shape = status, color = risk)) +
    geom_point() +
    geom_rug() +
    ggtitle(paste0("Generalized PCA of ICGC data expression with ",  sign, " / p-val: ", signif(p.val, digits = 3), " / auc: ", round(auc_uno, digits = 2))) +
    xlab("PC1") +
    ylab("PC2") +
    #xlab(paste0("PC1, VarExp: ", gpca[1], "%")) +
    #ylab(paste0("PC2, VarExp: ", gpca[2], "%")) +
    theme(plot.title = element_text(hjust = 0.5))+
    #coord_fixed(ratio = sd_ratio) +
    scale_shape_manual(values = c(15,4)) + 
    #scale_color_manual(values = c("#AF58BA", "#00CD6C")) + theme(aspect.ratio = 1) + 
    scale_color_manual(values = c("red3", "orange1", "green4")) + theme(aspect.ratio = 1) + 
    ggsave(paste0("../plots/icgc_3_cut_filt/gpca_icgc_", sign , ".pdf"), width = 11, height = 7, units = c("in"))
  }
}
}
```

<!-- # UMAP ICGC -->

<!-- ```{r} -->
<!-- plot.umap <- function(x, labels, -->
<!--          main="A UMAP visualization of the ICGC dataset", -->
<!--          colors=c("#ff7f00", "#e377c2", "#17becf"), -->
<!--          pad=0.1, cex=0.6, pch=19, add=FALSE, legend.suffix="", -->
<!--          cex.main=1, cex.legend=0.85) { -->

<!--   layout = x -->
<!--   if (is(x, "umap")) { -->
<!--     layout = x$layout -->
<!--   } -->

<!--   xylim = range(layout) -->
<!--   xylim = xylim + ((xylim[2]-xylim[1])*pad)*c(-0.5, 0.5) -->
<!--   if (!add) { -->
<!--     par(mar=c(0.2,0.7,1.2,0.7), ps=10) -->
<!--     plot(xylim, xylim, type="n", axes=F, frame=F) -->
<!--     rect(xylim[1], xylim[1], xylim[2], xylim[2], border="#aaaaaa", lwd=0.25) -->
<!--   } -->
<!--   points(layout[,1], layout[,2], col=colors[as.integer(labels)], -->
<!--          cex=cex, pch=pch) -->
<!--   mtext(side=3, main, cex=cex.main) -->

<!--   labels.u = unique(labels) -->
<!--   legend.pos = "topleft" -->
<!--   legend.text = as.character(labels.u) -->
<!--   if (add) { -->
<!--     legend.pos = "bottomleft" -->
<!--     legend.text = paste(as.character(labels.u), legend.suffix) -->
<!--   } -->

<!--   legend(legend.pos, legend=legend.text, inset=0.03, -->
<!--          col=colors[as.integer(labels.u)], -->
<!--          bty="n", pch=pch, cex=cex.legend) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- if(!require(umap)){install.packages("umap")} -->

<!-- icgc.umap = umap(data_icgc[, col_mRMR], random_state=1234) -->

<!-- plot.umap(icgc.umap, data_icgc$risk) -->

<!-- ``` -->

# MDS plot

<!-- ```{r}  -->
<!-- # install.packages("PoiClaClu") -->
<!-- library("PoiClaClu") -->
<!-- poisd <- PoissonDistance(data[, col_mRMR]) -->
<!-- rownames(samplePoisDistMatrix) <- rownames(data) -->
<!-- colnames(samplePoisDistMatrix) <- NULL -->

<!-- mdsPois <- as.data.frame(col_genes) %>% -->
<!--    cbind(cmdscale(samplePoisDistMatrix)) -->

<!-- ggplot(mdsPois, aes(x = `1`, y = `2`, color = dataset, shape = status)) + -->
<!--   geom_point(size = 3) + coord_fixed() + ggtitle("MDS with PoissonDistances") -->
<!-- ``` -->

```{r}
library(stats) # MDS

df <- data_icgc[, col_mRMR]
dist_MDS <- dist(scale(df))  # euclidean distances between the rows
fit <- cmdscale(dist_MDS,eig=TRUE, k=2) # k is the number of dim
#fit
fit$status <- ifelse(data_icgc$status==1, "Deceased", "Alive")

fit$risk <- data_icgc$risk
# plot solution 
p <- ggplot(data.frame(fit$points), aes(x=fit$points[,1], y=fit$points[,2],  shape = fit$status,  color = fit$risk)) + 
  labs(title="cMDS - Individuals",
       x="Dim1", y = "Dim2") + labs(colour='risk')  +
  geom_point() + geom_rug() +
  scale_shape_manual(values = c(15,4)) + 
  scale_color_manual(values = c("red3", "orange1", "green4"))
p 

```
# Nonmetric Multidimensional scaling (nMDS) in 2D  ####

```{r}
library(MASS)
dist_nMDS <- dist(scale(data_icgc[, col_mRMR]))  # euclidean distances between the rows
fit_nMDS <- isoMDS(dist_nMDS, k=2) # k is the number of dim
#fit_nMDS
fit_nMDS$status <- ifelse(data_icgc$status==1, "Deceased", "Alive")
fit_nMDS$risk <- data_icgc$risk

p <- ggplot(data.frame(fit_nMDS$points), aes(x=fit_nMDS$points[,1], y=fit_nMDS$points[,2],  shape = fit_nMDS$status, color = fit_nMDS$risk)) + 
  labs(title="nMDS - Individuals",
       x="Dim1", y = "Dim2") + labs(colour='risk')  +
  geom_point() + geom_rug() +
  scale_shape_manual(values = c(15,4)) + 
  scale_color_manual(values = c("red3", "orange1", "green4"))
p 
```


# Nonmetric Multidimensional scaling (nMDS) in 3D  ####

```{r}
library(plot3D)

library(car)

dist_nMDS <- dist(scale(data_icgc[, col_mRMR]))  # euclidean distances between the rows
fit_nMDS <- isoMDS(dist_nMDS, k=3) # k is the number of dim
#fit_nMDS

x <- fit_nMDS$points[,1]
y <- fit_nMDS$points[,2]
z <- fit_nMDS$points[,3]

scatter3D(x, y, z, xlab="Coordinate 1", ylab="Coordinate 2", zlab="Coordinate 3", main="Metric MDS", type="n") # plot solution 

text3D(x, y, z, labels = data_icgc$risk, cex=.7, col = c("pink", "lightgreen"))
```


# T-Distributed Stochastic Neighbor Embedding ####

```{r}
if(!require('tsne')){install.packages("tsne")} #  A "pure R" implementation of the t-SNE algorithm.
library(tsne)  


colors = rainbow(length(unique(data_icgc$risk)))
names(colors) = unique(data_icgc$risk)

ecb = function(x,y){ plot(x,t='n'); text(x,labels=data_icgc$risk, col=colors[data_icgc$risk]) }

tsne_icgc = tsne(data_icgc[,col_mRMR], epoch_callback = ecb, perplexity=50)


```



```{r}

load(file = "../data/2.data.signatures.rda")

## Fit a Cox model


library(tidyverse)
## https://github.com/tidyverse/tibble/issues/395
options(crayon.enabled = FALSE)
## Used for the dataset.
library(survival)
## Used for visualizaiton.
library(survminer)

```

```{r}


sign <- gsign_kidney["fs.mRMR", "signature"][[1]]
sign <- intersect(sign, colnames(data))
data.mRMR <- data[data$dataset == "TCGA", c("obs.time", "status", sign)]


coxph1 <- coxph(as.formula(paste0("Surv(obs.time, status) ~ " , paste(sign, collapse= " + "))),
               data = data.mRMR)



## Obtain the linear predictor
data.mRMR$lp <- predict(coxph1, type = "lp")
data.mRMR

library(survivalROC)
## Define a helper functio nto evaluate at various t
survivalROC_helper <- function(t) {
    survivalROC(Stime        = data.mRMR$obs.time,
                status       = data.mRMR$status,
                marker       = data.mRMR$lp,
                predict.time = t,
                method       = "NNE",
                span = 0.25 * nrow(data.mRMR)^(-0.20))
}
labels_obs.time <- c("180" = "6 months",
                     "365" = "1 year",
                     "730" = "2 years", 
                     "1095" = "3 years", 
                     "1460" = "4 years", 
                     "1825" = "5 years", 
                     "2555" = "7 years",
                     "3650" = "10 years")
## Evaluate every 180 days
survivalROC_data <- tibble(t = c(180, 365,  730, 1095, 1460, 1825, 2555, 3650)) %>%
    dplyr::mutate(survivalROC = purrr::map(t, survivalROC_helper),
           ## Extract scalar AUC
           auc = map_dbl(survivalROC, magrittr::extract2, "AUC"),
           ## Put cut off dependent values in a data_frame
           df_survivalROC = purrr::map(survivalROC, function(obj) {
               as_tibble(obj[c("cut.values","TP","FP")])
           })) %>%
    dplyr::select(-survivalROC) %>%
    unnest() %>%
    arrange(t, FP, TP)
## Plot
survivalROC_data %>%
    ggplot(mapping = aes(x = FP, y = TP)) +
    geom_point() +
    geom_line() +
    geom_label(data = survivalROC_data %>% dplyr::select(t,auc) %>% unique,
               mapping = aes(label = sprintf("%.3f", auc)), x = 0.5, y = 0.5) +
    facet_wrap( ~ t, labeller = as_labeller(labels_obs.time),  ncol = 4) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
          legend.key = element_blank(),
          plot.title = element_text(hjust = 0.5),
          strip.background = element_blank())
```

```{r warning=FALSE}

for(s in c(1:nrow(gsign_kidney))){ 
sign.id   <- gsign_kidney$id[s]
sign <- gsign_kidney[sign.id, "signature"][[1]]
sign <- intersect(sign, colnames(data))

data.sign <- data[data$dataset == "TCGA", c("obs.time", "status", sign)]

try({
coxph1 <- coxph(as.formula(paste0("Surv(obs.time, status) ~ " , paste(sign, collapse= " + "))),
               data = data.sign)



## Obtain the linear predictor
data.sign$lp <- predict(coxph1, type = "lp")

library(survivalROC)
## Define a helper functio nto evaluate at various t
survivalROC_helper <- function(t) {
    survivalROC(Stime        = data.sign$obs.time,
                status       = data.sign$status,
                marker       = data.sign$lp,
                predict.time = t,
                method       = "NNE",
                span = 0.25 * nrow(data.sign)^(-0.20))
}

pred <- survivalROC(Stime    = data.sign$obs.time,
                status       = data.sign$status,
                marker       = data.sign$lp,
                predict.time = 365,
                method       = "NNE",
                span = 0.25 * nrow(data.sign)^(-0.20) )

print(paste0(sign.id, ": AUC = ", round(pred$AUC,3)))

labels_obs.time <- c("180" = "6 months",
                     "365" = "1 year",
                     "730" = "2 years", 
                     "1095" = "3 years", 
                     "1460" = "4 years", 
                     "1825" = "5 years", 
                     "2555" = "7 years",
                     "3650" = "10 years")
## Evaluate intervals
survivalROC_data <- tibble(t = c(180, 365,  730, 1095, 1460, 1825, 2555, 3650)) %>%
    dplyr::mutate(survivalROC = purrr::map(t, survivalROC_helper),
           ## Extract scalar AUC
           auc = map_dbl(survivalROC, magrittr::extract2, "AUC"),
           ## Put cut off dependent values in a data_frame
           df_survivalROC = purrr::map(survivalROC, function(obj) {
               as_tibble(obj[c("cut.values","TP","FP")])
           })) %>%
    dplyr::select(-survivalROC) %>%
    unnest() %>%
    arrange(t, FP, TP)
## Plot
p <- survivalROC_data %>%
    ggplot(mapping = aes(x = FP, y = TP)) +
    geom_point() +
    geom_line() +
    geom_label(data = survivalROC_data %>% dplyr::select(t,auc) %>% unique,
               mapping = aes(label = sprintf("%.3f", auc)), x = 0.5, y = 0.5) +
    facet_wrap( ~ t, labeller = as_labeller(labels_obs.time),  ncol = 4) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
          legend.key = element_blank(),
          plot.title = element_text(hjust = 0.5),
          strip.background = element_blank())

  pdf(file=paste0("../plots/roc/TCGA-", sign.id,".pdf"), width = 14, height = 10)
  par(mar = c(4, 4, 4, 4))
  print(p)
  dev.off()
  }, silent = T)
}

```


```{r warning=FALSE}

for(s in c(1:nrow(gsign_kidney))){ 
sign.id   <- gsign_kidney$id[s]
sign <- gsign_kidney[sign.id, "signature"][[1]]
sign <- intersect(sign, colnames(data))

data.sign <- data[data$dataset == "ICGC", c("obs.time", "status", sign)]

try({
coxph1 <- coxph(as.formula(paste0("Surv(obs.time, status) ~ " , paste(sign, collapse= " + "))),
               data = data.sign)



## Obtain the linear predictor
data.sign$lp <- predict(coxph1, type = "lp")

library(survivalROC)
## Define a helper functio nto evaluate at various t
survivalROC_helper <- function(t) {
    survivalROC(Stime        = data.sign$obs.time,
                status       = data.sign$status,
                marker       = data.sign$lp,
                predict.time = t,
                method       = "NNE",
                span = 0.25 * nrow(data.sign)^(-0.20))
}

pred <- survivalROC(Stime    = data.sign$obs.time,
                status       = data.sign$status,
                marker       = data.sign$lp,
                predict.time = 365,
                method       = "NNE",
                span = 0.25 * nrow(data.sign)^(-0.20) )

print(paste0(sign.id, ": AUC = ", round(pred$AUC,3)))

labels_obs.time <- c("180" = "6 months",
                     "365" = "1 year",
                     "730" = "2 years", 
                     "1095" = "3 years", 
                     "1460" = "4 years", 
                     "1825" = "5 years", 
                     "2555" = "7 years",
                     "3650" = "10 years")
## Evaluate intervals
survivalROC_data <- tibble(t = c(180, 365,  730, 1095, 1460, 1825, 2555, 3650)) %>%
    dplyr::mutate(survivalROC = purrr::map(t, survivalROC_helper),
           ## Extract scalar AUC
           auc = map_dbl(survivalROC, magrittr::extract2, "AUC"),
           ## Put cut off dependent values in a data_frame
           df_survivalROC = purrr::map(survivalROC, function(obj) {
               as_tibble(obj[c("cut.values","TP","FP")])
           })) %>%
    dplyr::select(-survivalROC) %>%
    unnest() %>%
    arrange(t, FP, TP)
## Plot
p <- survivalROC_data %>%
    ggplot(mapping = aes(x = FP, y = TP)) +
    geom_point() +
    geom_line() +
    geom_label(data = survivalROC_data %>% dplyr::select(t,auc) %>% unique,
               mapping = aes(label = sprintf("%.3f", auc)), x = 0.5, y = 0.5) +
    facet_wrap( ~ t, labeller = as_labeller(labels_obs.time),  ncol = 4) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
          legend.key = element_blank(),
          plot.title = element_text(hjust = 0.5),
          strip.background = element_blank())

  pdf(file=paste0("../plots/roc/ICGC-", sign.id,".pdf"), width = 14, height = 10)
  par(mar = c(4, 4, 4, 4))
  print(p)
  dev.off()
  }, silent = T)
}

```
